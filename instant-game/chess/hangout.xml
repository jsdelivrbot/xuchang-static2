<?xml version="1.0" encoding="UTF-8" ?>
<Module>
  <ModulePrefs title="AnywhereBoardGames">
    <Require feature="rpc"/>
    <Require feature="views"/>
  </ModulePrefs>
  <Content type="html">
    <![CDATA[
<html>
    <head>
	  <script src="//plus.google.com/hangouts/_/api/v1/hangout.js?v=1.1"></script>
<!--
   <script src="//talkgadget.google.com/hangouts/_/api/hangout.js?v=1.1"></script>
   <script src="//hangoutsapi.talkgadget.google.com/hangouts/_/api/hangout.js?v=1.1"></script>
-->

	    <link href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/smoothness/jquery-ui.css" rel="stylesheet" type="text/css"/>
	    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
	    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js" type="text/javascript"></script>
		<style type="text/css">
			#draggable { width: 100px; height: 70px; background: silver; }
			.ui-widget-overlay {opacity: 0;}
			.popup .ui-dialog-titlebar {display: none; visibility: hidden;}
			.popup .ui-button { text-align: left;}
			.ui-dialog-content label {width: 20%; display: inline-block; text-align: right;}
		</style>
		<script type="text/javascript">

// Detection used for Chrome-specific bug fixes
var util_is_chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

// Bug fix to allow scroll bars to work on mouse down events:
function util_is_in_scrollbar(event){
	if ((event.clientX > ($(window).width()-17)) ||
		(event.clientY > ($(window).height()-17))){
		return (true);
	}
	return (false);
}


// TODO: IMMEDIATE FIX THIS NAME TO POS AND REVIEW CHANGES
/*
 * util_page_to_board_coord - converts page to board coordinates based upon 
 * the current scrollbar location
 * 
 * @param page The (left, top) page coordinates
 * @return board The (left, top) board coordinates
 */
function util_page_to_board_coord(coord){
	var left = coord.left;
	var top = coord.top;
    left += $("#board").scrollLeft();
	top += $("#board").scrollTop();
	return ({left: left, top: top});
}

/*
 * util_board_to_page_coord - converts board to page coordinates based upon 
 * the current scrollbar location
 * 
 * @param page The (left, top) page coordinates
 * @return board The (left, top) board coordinates
 */
function util_board_to_page_coord(coord){
	var left = coord.left;
	var top = coord.top;
    left -= $("#board").scrollLeft();
	top -= $("#board").scrollTop();
	return ({left: left, top: top});
}

/*
 * util_is_touch_event - Helper function to determine if an event is a touch event
 * 
 * @param event The mouse or touch event
 */
function util_is_touch_event(event){
	return ((typeof event.touches != 'undefined') || (typeof event.changedTouches != 'undefined'));
}

/*
 * util_ignore_click_from_touch - An implementation of the Google "clickbuster"
 * to ignore clicks that result from touch events we have already handled
 * see http://code.google.com/mobile/articles/fast_buttons.html
 * 
 * Here we try a simpler implementation that ignores clicks for the next 0.5 seconds.
 */
function util_ignore_click_from_touch(){
	var ignore_callback = function(event){
		event.stopPropagation();
		event.preventDefault();
	};
	var remove_callback = function(){
		document.removeEventListener('click',ignore_callback,true);
	}
	document.addEventListener('click',ignore_callback,true);
	setTimeout(remove_callback, 1000);
}

/*
 * util_get_event_coordinates - Helper function to get the event coordinates for either a 
 * mouse or touch event
 * 
 * @param event The mouse or touch event
 * @return coord (x, y) coordinates for the event
 */
function util_get_event_coordinates(event){
	var coord;
	if (util_is_touch_event(event)){
		// If this is a touch event, use the first touch
		// TODO: LOW - Allow multiple touches and use the closest touch to the object (targetTouches)
		if (event.touches.length > 0){
			coord = {
				x: event.touches[0].pageX, 
				y: event.touches[0].pageY
			};
		} else {
			coord = {
				x: event.changedTouches[0].pageX, 
				y: event.changedTouches[0].pageY
			};			
		}
	} else {
		coord = {
			x: event.pageX, 
			y: event.pageY
		};
	}
	return (coord);
}

/*
 * util_get_event_board_coordinates - Helper function to get the event coordinates for either a 
 * mouse or touch event in relation to the top/left of the board
 * 
 * @param event The mouse or touch event
 * @return coord (x, y) coordinates for the event
 */
function util_get_event_board_coordinates(event){
	var coord = util_get_event_coordinates(event);
	return ({x: (coord.x += $("#board").scrollLeft()),
			 y: (coord.y += $("#board").scrollTop())});
}

/*
 * util_clone - Does a shallow clone of an object or array
 * 
 * @param orig Original object or array
 */
function util_clone(orig){
	if (orig instanceof Array){
		return orig.slice(0);
	} else {
		return ($.extend({},orig));
	}
}
/*
 * util_create_ui_overlay - Generates a ui-widget-overlay, sets the window resize
 * callback to manipulate it, and returns the DOM object
 *
 * @param click_callback Callback(event) for click event
 * @return ui_overlay DOM object
 */
function util_create_ui_overlay(click_callback){
	// Note: We append this to the body to ensure full coverage when the board resizes
	var js_overlay = $('<div class="ui-widget-overlay"></div>').css('opacity',0).appendTo('body');
	js_overlay.css('position','absolute');
	js_overlay.css('z-index',1002);
	js_overlay.width($(document).width());
	js_overlay.height($(document).height());
	var set_overlay_dimension = function (){
		js_overlay.width($(document).width());
		js_overlay.height($(document).height());
	}
	$(window).bind("resize",set_overlay_dimension);
	js_overlay.bind("click",function(event){
		$(window).unbind("resize",set_overlay_dimension);
		js_overlay.remove();
		if (click_callback){
			return (click_callback(event));
		}
		else {
			return true;
		}
	});
	return (js_overlay.get(0))
}

function util_ignore_event(event){
	event.preventDefault();
	return(false);
}


function util_get_browser_width(){
  if( typeof( window.innerWidth ) == 'number' ) {
    //Non-IE
    return window.innerWidth;
  } else if( document.documentElement && document.documentElement.clientWidth ) {
    //IE 6+ in 'standards compliant mode'
    return document.documentElement.clientWidth;
  } else {
    //IE 4 compatible
    return document.body.clientWidth;
  }
}

function util_set_position(piece, position){
	$(piece).css({'left': (position.left + "px"), 'top': (position.top + "px")});
}

function util_get_position(piece) {
	return ({
				'left': parseInt($(piece).css("left"),10),
				'top': parseInt($(piece).css("top"),10)
			});
}
/*
 * Creates a simple pop-up menu.
 *
 * @param menu_items_config Array of (label, callback, args) to create the menu items
 * @param parent DOM object into which the pop-up menu is placed
 * @param position Client position (top, left) pair for the placement of the menu
 * @param cancel_callback A callback if the menu is closed by clicking the overlay
 * @return menu The jQuery dialog object
 */

function create_popup_menu(menu_items_config, parent, position, cancel_callback){
	var i, menu, menu_item;
	// Create and add the menu items
	menu = $('<div style="display:none;"></div>');
	// Add to the parent
	parent.append(menu);
	// Given a menu config, this creates a hander to call the callback and close the dialog
	function popup_callback_maker(config){
		return function(event) { 
			menu.dialog('close');
			menu.remove();
			return config.callback(event,config.args);
		};		
	}
	// Now create the menu items with the appropriate callback
	for( i in menu_items_config){
		menu_item = $('<a href="javascript: void(0);">' +
			menu_items_config[i].label + '</a>');
		menu_item.num = i;
		menu_item.bind('click',popup_callback_maker(menu_items_config[i]));
		menu.append(menu_item);
	}
	// Style the menu
	menu.css('padding', 0);
	// Turn links unto jquery ui buttons
	menu.find('a').css('display','block').button();
	// Set up the dialog box
	menu.dialog({
		dialogClass: 'popup bga_small_text_dialog',
		autoOpen: false,
		modal: true,
		resizable: false,
		width: '150',
		height: 'auto',
		minHeight: 'auto',
		minWidth: '150'
	});
	menu.dialog('option','position',[position.left, position.top]);
	// When the dialog opens, set the overlay to close the dialog if you click elsewhere
	menu.bind('dialogopen', function(event, ui) {
		$('.popup .ui-dialog-titlebar').hide();
		$('.ui-widget-overlay').unbind('click');
		$('.ui-widget-overlay').css('opacity',0);
//		$('.ui-widget-overlay').bind('mousedown touchstart',function(event) {
		$('.ui-widget-overlay').bind('click',function(event) {
			menu.dialog('close');
			menu.remove();
			if (cancel_callback){
				cancel_callback(event);
			}
			event.preventDefault();
			return false;
		});
		// Unset the hover that the jquery dialog places on the first item
		menu.find('a').removeClass('ui-state-focus ui-state-hover');
	});
	// Now open the dialog
	menu.dialog('open');
	return(menu);
}

/* Once thing we don't really have here is an object representing the model of
 * the world. Right now we let the piece_ui utilize the piece objects that are
 * generated by the DOM to hold all of the model status.  If we start allowing
 * client side zooming, or other interesting changes, this could be a problem.
 * On the other hand, since z-indexing requires special care (to avoid long term
 * holes), we'd have to pick up that responsibility.
 * 
 * Another interesting issue is that we have specialized functions for moving,
 * locking, etc.  Moving was split out so that we could send multiple close 
 * move commands, and allow the resulting ajax not pile up.  Instead we could
 * replace almost all of these functions with a general world_piece_model_update
 * or even a world_model_update function that could take an array of the changes
 * and act accordingly.
 */

// Keep track of the largest index we use for a piece with the server
var world_max_piece_index = -1;

// For now, use the local PHP server to share world data
var world_server_url = "../server/world.php";

// Hold the current local state
var world_local_state = {};

// Allow cross-domain requests in Ajax
$.support.cors = true;

/*
 * world_get_new_piece_index - Gets the index of the next piece to be added
 * to the world.
 * 
 * TODO: LOW -  There is a small race condition if two pieces are added simultaneously
 * TODO: LOW - Fill in any null holes from previously deleted pieces first
 */
function world_get_new_piece_index(){
	world_max_piece_index ++;
	return world_max_piece_index;
}

/*
 * world_add_piece - Adds a piece to the world server
 * 
 * @param piece_data Object containing new piece data
 */
function world_add_piece(piece_data){
	var piece_index = world_get_new_piece_index();
	world_update_piece(piece_index,piece_data);
}

/*
 * flatten_recursive_structure - This takes a structured recursive array/object
 * and turns it into a single associative array (using "|" to separate
 * keys) suitable for use in Google Hangout state
 * 
 * @param update The update to the world
 * @param base_key (defaults to "") used for recursion
 * @param flat_update (defaults to {}) used for recursion
 */
function flatten_recursive_structure(update, base_key, flat_update){
	base_key = (typeof base_key !== 'undefined') ? base_key : "";
	flat_update = (typeof flat_update !== 'undefined') ? flat_update : {};

	if ($.isArray(update) || $.isPlainObject(update)){
		$.each(update, function(k, e){
			var new_key = base_key ? (base_key + "|" + k) : k;
			if ($.isArray(e) || $.isPlainObject(e)){
				flatten_recursive_structure(e, new_key, flat_update);
			} else {
				if ((e == null) || (e == undefined)){
					flat_update[new_key] = "_NULL_";
				} else {
					flat_update[new_key] = e.toString();
				}
			}
		});
	}
	return (flat_update);
}

/*
 * unflatten_recursive_structure - This a flattened associative array
 * and returns it to a structured recursive array/object.
 * 
 * @param flat_update The flattened update
 */
function unflatten_recursive_structure(flat_update){
	var update = {};

	function compoundkey_set(u, k, v){
		k = k.split("|");
		var f = k.shift();
		while (k.length > 0){
			if (!(u[f] instanceof Object)){
				// Create object for parent of not there
				u[f] = {};
			}
			u = u[f];
			f = k.shift();
		}
		if (v == "_NULL_"){
			u[f] = null;
		} else {
			u[f] = v;
		}
	}

	// TODO: IMMEDIATE - SLOW DOWN rotate
	// TODO: IMMEDIATE - Check Lock and other booleans for string conversion problems
	// TODO: MEDIUM - Move Split Code and Split on pieces if possible
	// TODO: LOW - Move Split Code really high, time, and pool updates by piece
	// TODO: DETERMINE IF WE REALLY NEED TO SORT KEYS IF WE ASSUME EVERYTHING IS AN OBJECT
	// Grab the keys
	var keys = [];
	$.each(flat_update, function(k, v){
		keys.push(k);
	});
	// Now sort the keys
	keys.sort();
	// Now loop through the keys and setting the update object (so we hit parents before children)
	$.each(keys, function(i, k){
		compoundkey_set(update, k, flat_update[k]);
	});
	return (update);
}

/*
 * find_deletions - This takes the flat updates, looks for _NULL_, and if found
 * locates all of the keys currently in the world to remove
 * 
 * @param flat_update The current flat update
 */
function find_deletions(flat_update){
	var deletions = [];
	$.each(flat_update, function(k, e){
		var child_prefix = k + "|";
		if (e == "_NULL_"){ // We found a deletion
			$.each(world_local_state, function(ck,ce){
				if ((ck.indexOf(child_prefix) == 0)){ // We found a child
					deletions.push(ck);
				}
			});
		}
	});
	return (deletions);
}

// Given a set up submitDelta updates and deletes, this returns true if the update is too big
// This code is updated from hangout.js (thus it is cryptic)
function update_too_big(a,c){
	var g=500;
	for(b in a) g+=b.length+a[b].length+100;
	for(e=0;e<c.length;e++)g+=c[e].length+100;
	return(g>1E4);
}

/* world_queue_update - Queues an update to be sent.  If we've done an update in the 
 * in the recent past, we delay the sending of another to avoid hitting Google Hangout's
 * throttle
 */
function world_queue_update(updates,deletes){
	if (!("queue" in world_queue_update)){
		world_queue_update.queue = [];
		world_queue_update.last_time = 0;
	}
	var next_update = {"u": updates,"d": deletes};
	world_queue_update.queue.push(next_update);
	if (!("loop_running" in world_queue_update)){
		world_queue_update.loop_running = true;
		var call_next_update = function(){
			// Pull the next update
			var n = world_queue_update.queue.shift();
			// Do we have more updates pending? If so, try to concatenate them
			while (world_queue_update.queue.length > 0) {
				var n2 = world_queue_update.queue[0];
				var combined = {"u": ($.extend({},n["u"],n2["u"])), 
								"d": n["d"].concat(n2["d"])};
				if (update_too_big(combined["u"],combined["d"])) break;
				n = combined;
				world_queue_update.queue.shift();
			}
			try {
				// Separate deletes from adds (to avoid having a duplicate in both), doing deletes first
				if (n["d"].length > 0){
					gapi.hangout.data.submitDelta({},n["d"]);
				}
				gapi.hangout.data.submitDelta(n["u"],[]);
			} catch (x) {
				console.log(x);
				alert('There was an error submitting the world information.  Please save your board and reload the application.');
			}
			world_queue_update.last_time = new Date().getTime();
			if (world_queue_update.queue.length > 0){
				setTimeout(call_next_update,150);
			} else {
				// Out of requests so stop
				delete world_queue_update.loop_running;
			}
		}
		var now = new Date().getTime();
		if ((now - world_queue_update.last_time) < 150){
			// If we last updated recently, wait a little
			setTimeout(call_next_update,150 - (now - world_queue_update.last_time));
		} else {
			// Else start now
			call_next_update();
		}
	}
}

/*
 * world_update - Sends an update array to the world.  Any subsequent calls will be 
 * combined into a single update until the previous ajax call is completed.
 * 
 * @param update The update to implement in the world
 */
function world_update(update){
	var flat_updates = flatten_recursive_structure(update);
	var flat_deletions = find_deletions(flat_updates);
	// Special case: deleting the world
	if (update === 0){
		// Increment the new count
		var new_count = 1;
		if ("__new" in world_local_state){
			new_count = Number(world_local_state["__new"] + 1);
		}
		flat_updates = {"__new": new_count.toString()};
		// Remove all keys
		flat_deletions = [];
		$.each(world_local_state, function(k,e){
			if (k != "__new"){
				flat_deletions.push(k);
			}
		});
	}
	// If our update is too big split it up
	if (!update_too_big(flat_updates,flat_deletions)){
		world_queue_update(flat_updates,flat_deletions);
	} else {
		var update_keys = [];
		var inc_updates = {}, inc_deletions = [];
		var k, l = 0;
		// Gather up all update keys
		$.each(flat_updates,function(k,v){
			update_keys.push(k);
		});
		// Pull off 15 keys of each type to update
		while ((update_keys.length > 0) || (flat_deletions.length > 0)){
			if (update_keys.length > 0){
				k = update_keys.pop();
				inc_updates[k] = flat_updates[k];
				l++;
			}
			if (flat_deletions.length > 0){
				inc_deletions.push(flat_deletions.pop());
			}
			// Send in packs of 15
			if ((l > 14) || (inc_deletions.length > 14)){
				world_queue_update(inc_updates,inc_deletions);
				inc_updates = {};
				l = 0;
				inc_deletions = [];
			}
		}
		// Send any left
		if ((l > 0) || (inc_deletions.length > 0)){
			world_queue_update(inc_updates,inc_deletions);
		}
	}
}

/*
 * world_update_piece - Convenience function to update a piece given a piece
 * index and an array of attributes
 * 
 * @param piece_index Index of the peice to update
 * @param piece_update Object containing the attributes to update 
 */
function world_update_piece(piece_index, piece_update){
	var update = {
		"pieces": new Object()
	};
	update.pieces[piece_index] = piece_update;
	world_update(update);
}

/*
 * world_update_piece_accumulate - Accumulates piece updates until
 * world_update_piece_accumulate_flush is called.  This is useful for easily
 * updating many pieces at once.  Changes to the same piece will
 * completely overwrite old ones.
 * ***NOTE*** FOR HANGOUT WE CAN'T ACCUMULATE TOO MUCH, SO WE INTENTIONALLY BREAK THIS
 * 
 * @param piece_index Index of the peice to update
 * @param piece_update Object containing the attributes to update 
 */
function world_update_piece_accumulate(piece_index, piece_update){
	if (!("update" in world_update_piece_accumulate)){
		world_update_piece_accumulate.update = {
			"pieces": new Object()
		};
	}
	world_update_piece_accumulate.update.pieces[piece_index] = piece_update;
	world_update(world_update_piece_accumulate.update);
	delete world_update_piece_accumulate.update;
}

/*
 * world_update_piece_accumulate_flush - Sends any accumulated piece updates
 * gathered in world_update_piece_accumulate() to the server.
 * ***NOTE*** FOR HANGOUT WE CAN'T ACCUMULATE TOO MUCH, SO WE INTENTIONALLY BREAK THIS
 */
function world_update_piece_accumulate_flush(){
}

/*
 * world_load_from_data - Loads the world from a data object (read from
 * a file)
 * 
 * @param data The ABG data file
 * @param clear_world Boolean if we should replace the current world
 */
function world_load_from_data(data, clear_world){
	// Set the index for our next piece
	var next_piece_index = (world_max_piece_index + 1);
	// Clear the world
	if (clear_world) {
		world_update(0);
		next_piece_index = 0;
	}
	// Cycle through pieces and add them
	if ("pieces" in data){
		$.each(data["pieces"],function(i,p){
			// Convert face data to JSON
			if ("faces" in p){
				p["faces_array"] = JSON.stringify(p["faces"]);
				delete p["faces"];
			}
			// Make sure it appears
			p["client_id"] = -1;
			world_update_piece(next_piece_index,p);
			next_piece_index++;
		});
	} else {
		alert('Sorry, but the URL you provided did not contain any pieces');
	}
	
}

/*
 * world_load_from_url - Uses Ajax to read the contents of an ABG file
 * and either adds it or replaces the current world to it
 * 
 * @param url The URL for the Word
 * @param clear_world Boolean if we should replace the current world
 */
function world_load_from_url(url, clear_world){
	var world_load_failure = function(data, textStatus, errorThrown){
		alert("Sorry, we were unable to read the board game data.  (Please note that loading a board from a URL is not supported in IE9.)")
	}
	var world_load_handler = function(data){
		try {
			data = JSON.parse(data);
		} catch (x) {
			alert('The provided URL does not contain valid board game data.');
			return;
		}
		world_load_from_data(data, clear_world);
	}
	$.ajax({
		url: url,
        success: world_load_handler,
        error: world_load_failure,
        dataType: "text"
	});
}

/*
 * world_load_from_file - Uses FileReader to read the contents of an ABG file
 * and either adds it or replaces the current world to it
 * 
 * @param file The file object
 * @param clear_world Boolean if we should replace the current world
 */
function world_load_from_file(file, clear_world){
	if (window.FileReader === undefined){
		alert("Sorry, but your browser does not support client-side file reading. " +
			"Please consider getting the latest version of Chrome or Firefox");
	}
	var file_reader = new FileReader();
	file_reader.onError = function(){
		alert("Sorry, we were unable to read the file.")
	}
	file_reader.onload = function(evt){
		var data;
		try {
			data = JSON.parse(evt.target.result);
		} catch (x) {
			alert('The provided file does not contain valid board game data.');
			return;
		}
		world_load_from_data(data, clear_world);
	}
	file_reader.readAsText(file);
}

/* world_save_world - Saves the current world to a file (in a new window)
 */
function world_save_world(){
	var pieces = [];
	$.each(g_pieces,function(i,piece){ // Note g_pieces is in piece_ui.js
		var offset = util_page_to_board_coord($(piece).offset());
		pieces.push({
			"faces": piece.faces, // Note: for download we keep the array as is (not JSON)
			"face_width": piece.face_width,
			"x": (offset.left), 
			"y": (offset.top),
			"z": piece.z,
			"lock": piece.lock,
			"shield": piece.shield,
			"orientation": piece.orientation,
			"face_showing": piece.face_showing,
			"css_class": piece.css_class,
			"event_callback": piece.event_callback,
			"custom_html": escape(piece.custom_html)
		});
	});
	var world = { "_new":1, "pieces": pieces};

	try {
		window.open('data:text/json;filename=board.abg,' + 
					encodeURIComponent(JSON.stringify(world)),
					'board.abg');
	} catch (x) {
		alert("Sorry, we are unable to save the board.  (Please note that saving board state is not supported in IE9.)");
	}
}

/*
 * world_on_new_piece_handler - This is a handler function(piece_index, piece_data)
 * that is set by the code interested in listening to piece additions to the world
 * When a new piece is added, the piece_index is set to the index used by the world
 * to reference changes (the index for the change handler in 
 * world_on_piece_change_handlers) and piece_data is an array holding any changed
 * data for the piece.
 */
var world_on_new_piece_handler = function(){};

/*
 *  world_on_piece_change_handlers - This is an array of change handlers 
 *  function(piece_data) that is set by the code interested in listening
 *  to piece changes.  The array is indexed by the piece_index (see
 *  world_on_new_piece_handler).
 */
var world_on_piece_change_handlers = {};

function execute_world_update(update){
	var piece_index;
	// Handle a new world
	if ((!(update instanceof Object)) || ("__new" in update)) {
		// Reset max piece index
		world_max_piece_index = -1;
		// Delete existing pieces
		for (piece_index in world_on_piece_change_handlers){
			world_on_piece_change_handlers[piece_index](null);
			// Unregister the handler
			delete world_on_piece_change_handlers[piece_index];
		}
		// Now add new pieces
		if ((update instanceof Object) && ("pieces" in update)){
			for (piece_index in update.pieces) {
				if (Number(piece_index) > world_max_piece_index){
					world_max_piece_index = Number(piece_index);
				}
				// Add the piece if it isn't null
				if (update.pieces[piece_index] instanceof Object){
					world_on_new_piece_handler(piece_index, update.pieces[piece_index]);
				}
			}
		}
	} else if ("pieces" in update) {
		// Iterate pieces, looking for new, updates, or deletes
		for (piece_index in update.pieces) {
			if ((update.pieces[piece_index] instanceof Object) && 
				(!(Number(piece_index) in world_on_piece_change_handlers))) {
				if (Number(piece_index) > world_max_piece_index){
					world_max_piece_index = Number(piece_index);
				}
				world_on_new_piece_handler(piece_index, update.pieces[piece_index]);
			} else if (piece_index in world_on_piece_change_handlers){
				world_on_piece_change_handlers[piece_index](update.pieces[piece_index]);
				// Check if the piece was deleted
				if (update.pieces[piece_index] === null){
					// Unregister the handler
					delete world_on_piece_change_handlers[piece_index];
				}
			}
		}
	}
}

/*
 * world_listener_start - Implements an loop that checks for updates from
 * the world server.  It calls "execute_world_update" if there is an update.
 */
function world_listener_start(){
	// When the state is updated, this handles the update data
	var world_update_handler = function(eventObj){
		var flat_update = {};
		var i, k, v;
		for (i = 0; i < eventObj.addedKeys.length; ++i){
			k = eventObj.addedKeys[i].key;
			v = eventObj.addedKeys[i].value;
			flat_update[k] = v;
			world_local_state[k] = v;
		}
		for (i = 0; i < eventObj.removedKeys.length; ++i){
			k = eventObj.removedKeys[i].key;
			delete world_local_state[k];
		}
		var update = unflatten_recursive_structure(flat_update);
//		console.log(JSON.stringify(update));
		execute_world_update(update);
	}
	// Get the initial state
	world_local_state = gapi.hangout.data.getState();
	if (world_local_state){
		var update = unflatten_recursive_structure(world_local_state);
//		console.log(JSON.stringify(update));
		execute_world_update(update);
		// See if the world is empty
		if (!("pieces" in update)){
			// See if data was passed in
			var appData = gadgets.views.getParams()['appData'];
			if (appData){
				world_load_from_url(appData,1);
			} else {
				world_load_from_url('https://dl.dropboxusercontent.com/u/10065648/abg/intro.abg.txt',1);
			}
		}
	}
	// Register our update andler
	gapi.hangout.data.onStateChanged.add(world_update_handler);
}

// Start the world listener
gapi.hangout.onApiReady.add(function(eventObj){
  try {
    if (eventObj.isApiReady){
      world_listener_start();	  
    }
  } catch (x) {
	alert("Sorry... there was a problem initializing the board.  Please reload the application (and make sure you are using an updated version of your browser). ")
	  console.log(x);
  }
});
/*
 *	piece_ui.js is responsible for displaying and allowing the user to
 *	manipulate the pieces on the board.
 *	
 *	It requires:
 *	 - The world javascript functions (world.js)
 *	 - A #board defined in HTML to add elements
 *	 
 *	NOTE ON BACKGROUND CLICK-AND-DRAG:
 *	With this code, we work hard to support both mouse and touch events.  In
 *	most cases, single touch events are treated identically to the mouse
 *	down and move events with one key exception: what to do when the background
 *	or locked pieces are dragged.  For touch devices, users expect the screen
 *	to pan and pinches to zoom.  For mouse devices, users expect multi-select
 *	to occur when the background or locked pieces are clicked and dragged.
 */

/*
 * g_pieces - This array holds all of the pieces on the board.  This is useful
 * for multi-select collision determiniation and z-index maintenance (to avoid
 * gaps in the z-index when a piece is moved to the bottom or top).
 */
var g_pieces = [];

/*
 * g_client_id - A unique client ID that can be used to ignore update messages
 * that we generated and have already displayed (like piece move and rotate)
 *
 * TODO: LOW - Make the client ID truly unique (currently low probability of hitting another client)
 */
var g_client_id = (""+Math.random()).split(".").pop();

/*
 * g_is_touch_device - if we encounter a touch device, we know to ignore some
 * keey events.  This is set when we encounter a touch event
 */
var g_is_touch_device = 0;

/**
 * on_new_piece_handler - Callback for when a new piece is added to the world
 * 
 * @param piece_idx The index of the piece in the world (needed for world update calls)
 * @param piece_data Data about the newly added piece
 */
function on_new_piece_handler(piece_idx, piece_data){
	var source = "";
	// Set some defaults if not there (this allows pieces to be split across multiple updates)
	if (!("z" in piece_data)){
		piece_data.z = 0;
	}
	if (!("x" in piece_data)){
		piece_data.x = 0;
	}
	if (!("y" in piece_data)){
		piece_data.y = 0;
	}
	if (!("face_showing" in piece_data)){
		piece_data.face_showing = 0;
	}
	if (!("faces_array" in piece_data)){
		piece_data.faces = [];
	} else {
		piece_data.faces = JSON.parse(piece_data.faces_array);
		source = piece_data.faces[piece_data.face_showing];
	}
	// TODO: Handle both "faces" and "faces_array" for backwards compatibility with save files
	// Unparse the face array

	// Create piece HTML in the proper location
	var jq_piece = $('<span class="piece" id="piece_' + piece_idx + 
		'" style="position: absolute; left: ' + piece_data.x + 'px; top: ' + piece_data.y + 'px;">' +
		'<img class="piece_face" src="' + source + '">' +
		'<div class="custom_html"></div></span>');
	// Add to the board
	$("#board").append(jq_piece);
	// Get the object for the piece itself
	var piece = jq_piece.get(0);
	// Add the piece to our global list
	g_pieces.push(piece);
	// Record the piece index into the piece object
	piece.world_piece_index = piece_idx;
	// Record the lock state into the piece object
	piece.lock = Number(piece_data.lock) ? piece_data.lock : 0;
	// Record if the piece is a shield
	piece.shield = Number(piece_data.shield) ? piece_data.shield : 0;
	// Record the faces
	piece.faces = piece_data.faces;
	// Set the piece face's width
	piece.face_width = "";
	if ("face_width" in piece_data){
		piece.face_width = piece_data.face_width;
		if (Number(piece_data.face_width) > 0){
			$(piece).find('.piece_face').attr('width',piece.face_width);
		} else {
			$(piece).find('.piece_face').removeAttr('width');
		}
	}
	// Initialize the z index
	set_piece_z_index(piece, Number(piece_data.z));
	// Set the face
	set_piece_face_showing(piece,piece_data.face_showing);
	// Record the orientation
	piece.orientation = piece_data.orientation ? Number(piece_data.orientation) : 0;
	set_piece_orientation(piece,piece.orientation);
	// Add the move handler
	$(piece).bind({
		mousedown: on_piece_touch_start
	});
	// Add mouse touch event (for mobile devices)
	if (piece.addEventListener){
		piece.addEventListener("touchstart",on_piece_touch_start,false);
	}
	// Set the piece CSS classes
	piece.css_class = piece_data.css_class ? piece_data.css_class : "";
	if (piece.css_class){
		$(piece).addClass(piece.css_class);
	}
	// Set the piece callback
	piece.event_callback = piece_data.event_callback ? piece_data.event_callback : "";
	// Set up custom HTML
	piece.custom_html = "";
	if ("custom_html" in piece_data){
		piece.custom_html = unescape(piece_data.custom_html);
		$(piece).find('.custom_html').html(piece.custom_html);
	}
	// Set up change handler for piece
	world_on_piece_change_handlers[piece_idx] = function(piece_data){
		if (piece_data === null){
			// Remove the piece from our global list
			g_pieces.splice($.inArray(piece,g_pieces),1);
			// If piece_data is null, then the piece is removed, so get rid of it
			$(piece).remove();
		} else {
			if ("client" in piece_data){
				piece.client = piece_data.client;
			}
			// Move the piece (as long as we didn't move it initially)
			if (("x" in piece_data) && ("y" in piece_data)){
				if (piece.client != g_client_id) {
					util_set_position(piece,{
						left: Number(piece_data.x), 
						top: Number(piece_data.y)
					});	
				}
			}
			// Rotate the piece (as long as we didn't rotate it initially)
			if ("orientation" in piece_data){
				if (piece.client != g_client_id) {
					piece.orientation = Number(piece_data.orientation);
					set_piece_orientation(piece,piece.orientation);
				}
			}
			// Set the shield status
			if ("shield" in piece_data){
				piece.shield = Number(piece_data.shield);
			}
			// Set z index
			if ("z" in piece_data){
				set_piece_z_index(piece, Number(piece_data.z));
			}
			// Update the faces
			if ("faces_array" in piece_data){
				piece.faces = JSON.parse(piece_data.faces_array);
				set_piece_face_showing(piece,piece.face_showing);
			}
			// Update he image width
			if ("face_width" in piece_data){
				piece.face_width = piece_data.face_width;
				if (Number(piece_data.face_width) > 0){
					$(piece).find('.piece_face').attr('width',piece.face_width);
				} else {
					$(piece).find('.piece_face').removeAttr('width');
				}
			}
			// Set the face that's showing
			if ("face_showing" in piece_data){
				set_piece_face_showing(piece,piece_data.face_showing);
			}
			// Set the lock status
			if ("lock" in piece_data) {
				piece.lock = Number(piece_data.lock);
			}
			// Set the piece CSS classes
			if ("css_class" in piece_data) {
				piece.css_class = piece_data.css_class;
				$(piece).attr('class','piece')
				if (piece.css_class){
					$(piece).addClass(piece.css_class);
				}
			}
			// Set the piece callback
			if ("event_callback" in piece_data) {
				piece.event_callback = piece_data.event_callback;
			}
			// Update the custom HTML
			if ("custom_html" in piece_data){
				piece.custom_html = unescape(piece_data.custom_html);
				$(piece).find('.custom_html').html(piece.custom_html);
			}
		}
	}
}

// Register our new piece handler (make sure it is registered before document load)
world_on_new_piece_handler = on_new_piece_handler; 

/*
 * compare_piece_z_indices - Compares the z-index for two pieces, returning
 * -1 if a.z < b.z, 1 if a.z > b.z, and 0 if a.z = b.z
 * 
 * @param a The first piece
 * @param b the second piece
 * @return comparison_value
 */
function compare_piece_z_indices(a,b){
	if (a.z < b.z){
		return (-1);
	} else if (a.z > b.z){
		return (1);
	} else {
		return (0);
	}
}

/*
 * correct_piece_z_indices - Iterates through all pieces, updating the z-indices so that
 * they are positive and there are no gaps, and then updates the world and the local
 * client for any piece that is moved
 */
function correct_piece_z_indices(){
	// First, sort the pieces by the z-index
	g_pieces.sort(compare_piece_z_indices);
	var z = 1; 	// Start at 1 to let shields be in the back
	var i;
	var piece_updates = {};
	var piece;
	$.each(g_pieces, function (i,piece){
		if (!piece.shield){ // Don't reorder shields
			if (piece.z != z){
				world_update_piece_accumulate(piece.world_piece_index, {
					"z": z
				});
				set_piece_z_index(piece, z);
			}
			z++;
		}
	});
	world_update_piece_accumulate_flush();
}

/*
 * pieces_highlight - Highlights pieces for movement, multi-select, etc.
 * 
 * @param pieces Array of pieces to highlight
 */
function pieces_highlight(pieces){
	$(pieces).css("opacity",0.5);
}

/*
 * pieces_unhighlight - Restores pieces from being highlighted
 * 
 * @param pieces Array of pieces to restore
 */
function pieces_unhighlight(pieces){
	$(pieces).css("opacity",1);
}

/*
 * pieces_call_event_callback - Calls the event callback for the pieces
 * 
 * @param pieces Array of pieces to execute the callback
 * @param event_name String name of the event
 */
function pieces_call_event_callback(pieces, event_name){
	var callback = 0;
	$.each(pieces,function(i,piece){
		if (piece.event_callback && (piece.event_callback in window)) {
			callback = window[piece.event_callback];
			callback(piece, event_name);
		}
	});
}

/*
 * pieces_roll - Flips each piece to a random side
 * 
 * @param pieces Array of pieces to roll
 * @param count Number of times to roll
 */
function pieces_roll(pieces, count){
	// For each piece update the face showing to a random face
	$.each(pieces,function(i,piece){
		if ((count > 0) && (piece.faces.length == 2)){
			// For a 2 sided piece, simply flip it until the last count
			piece.face_showing = (piece.face_showing + 1) % 2;
		} else {
			piece.face_showing = Math.floor(Math.random() * piece.faces.length);
		}
		set_piece_face_showing(piece,piece.face_showing);
		world_update_piece_accumulate(piece.world_piece_index,{
			"face_showing": piece.face_showing
		});
	});
	// Flush accumulated piece updates
	world_update_piece_accumulate_flush();
	if (count > 0){
		setTimeout(function(){
			pieces_roll(pieces,count-1)
			},200)
	}
}

/*
 * pieces_flip - Flips each piece to the next side in order
 * 
 * @param pieces Array of pieces to roll
 */
function pieces_flip(pieces){
	// For each piece update the face showing to a random face
	$.each(pieces,function(i,piece){
		piece.face_showing ++;
		if (piece.face_showing >= piece.faces.length){
			piece.face_showing = 0;
		}
		set_piece_face_showing(piece,piece.face_showing);
		world_update_piece_accumulate(piece.world_piece_index,{
			"face_showing": piece.face_showing
		});
	});
	// Flush accumulated piece updates
	world_update_piece_accumulate_flush();
}

/*
 * pieces_flip_to_first_side - Flips each piece to the first side
 * 
 * @param pieces Array of pieces to roll
 */
function pieces_flip_to_first_side(pieces){
	// For each piece update the face showing to a random face
	$.each(pieces,function(i,piece){
		piece.face_showing = 0;
		set_piece_face_showing(piece,piece.face_showing);
		world_update_piece_accumulate(piece.world_piece_index,{
			"face_showing": piece.face_showing
		});
	});
	// Flush accumulated piece updates
	world_update_piece_accumulate_flush();
}

/*
 * pieces_stack - Stacks the pieces at the location of the lowest piece
 * 
 * @param pieces Array of pieces to roll
 */
function pieces_stack(pieces){
	var lowest_piece = null;
	$.each(pieces,function(i,piece){
		if ((!lowest_piece) || (lowest_piece.z > piece.z)){
			lowest_piece = piece;
		}
	});
	if (lowest_piece){
        var position = util_get_position(lowest_piece);
		$.each(pieces,function(i,piece){
			set_piece_orientation(piece,0);
			util_set_position(piece,position);
			world_update_piece_accumulate(piece.world_piece_index,{
				"client": g_client_id,
				"x": position.left,
				"y": position.top,
				"orientation": 0
			});
		});
	}

	// Flush accumulated piece updates
	world_update_piece_accumulate_flush();
}


/*
 * pieces_shuffle - Shuffles a stack of pieces, by switching the location and orientation
 * of the pieces randomly
 * 
 * @param pieces Array of pieces to shuffle
 */
function pieces_shuffle(pieces){
	var o = util_clone(pieces);
	/* Fisher-Yates-like shuffle the copy of pieces */
	var j;
	var num_pieces = pieces.length;
	var temp = {};
	// Iterate over every piece in order (i=0,...,length-1)
	$.each(pieces,function(i,piece){
		// Randomly choose an index from i to pieces.length to swap
		j = Math.floor(Math.random() * (num_pieces - i)) + i;
		// Swap the position
		temp.position = util_clone(util_get_position(piece));
		util_set_position(piece, util_get_position(pieces[j]));
		util_set_position(pieces[j], temp.position);
		// Swap the orientation
		temp.orientation = piece.orientation;
		piece.orientation = pieces[j].orientation;
		pieces[j].orientation = temp.orientation;
		// Swap the z-index
		temp.z = piece.z;
		piece.z = pieces[j].z;
		pieces[j].z = temp.z;
	});
	// Now do the update on the server
	$.each(pieces,function(i,piece){
		set_piece_orientation(piece,piece.orientation);
		set_piece_z_index(piece, piece.z);
		var position = util_get_position(piece);
		world_update_piece_accumulate(piece.world_piece_index,{
			"client": g_client_id,
			"x": position.left,
			"y": position.top,
			"z": piece.z,
			"orientation": piece.orientation
		});
	});
	// Flush accumulated piece updates
	world_update_piece_accumulate_flush();
}


/*
 * move_pieces_to_front - moves an array of pieces to the top, and then updates the
 * z-indices for all pieces to fill gaps
 * 
 * @param pieces The array of pieces
 */
function move_pieces_to_front(pieces){
	var arr = util_clone(pieces); // Copy the array so we don't mess up the order
	arr.sort(compare_piece_z_indices);
	var new_z = 100000; // Start at a really high index
	$.each(arr,function(i,p){ // Move each piece to the top and increase the z index
		if (!p.shield){ // Ignore shields
			p.z = new_z;
			new_z ++;
		}
	});
	correct_piece_z_indices();
}

/*
 * move_pieces_to_back - moves an array of piece to the back, and updates the
 * z-indices for all pieces to fill gapes
 * 
 * @param pieces The piece DOM object
 */
function move_pieces_to_back(pieces){
	var arr = util_clone(pieces); // Copy the array so we don't mess up the order'
	arr.sort(compare_piece_z_indices);
	var new_z = 0 - arr.length; // Start at a big enough negative index
	$.each(arr,function(i,p){ // Move each piece to the top and increase the z index
		if (!p.shield){ // Ignore shields
			p.z = new_z;
			new_z ++;
		}
	});
	correct_piece_z_indices();
}

/*
 * set_piece_location - moves the piece to the given position visibly and
 * calls the world update for the piece
 * 
 * @param piece The piece DOM object
 * @param position (left, top) position for the piece
 * @param send_update boolean - if we actually send the update
 */
function set_piece_location(piece, position, send_update){
	// Move the piece locally
	util_set_position(piece, position);
	if (send_update){
		// Update the world (setting the client so we can ignore return messages)
		world_update_piece(piece.world_piece_index,{
		   "client": g_client_id,
		   "x": position.left,
		   "y": position.top
	   });
	}
}

/*
 * on_piece_touch_start - Handles a mouse down or touch event upon a piece
 * 
 * If a user clicks down upon a piece, we want to be able to do different things
 * depending upon if the user presses and drags or presses and releases (single click)
 * 
 * If a user presses and drags, we move the piece
 * If a user presses and releases without moving (a click):
 *
 * For touch support, we treat single touch events almost exactly like mouse events.
 * TODO: MEDIUM - Consider separating touch and mouse event handlers
 * 
 * @param event The mouse down or touch start event
 */
function on_piece_touch_start(event){
	// Bug fix for scroll bar
	if (util_is_in_scrollbar(event)) return (true);
	// For custom HTML, make sure the target does not have its own events
	if ($(event.target).hasClass('own_events')) return (true);
	// Is this a touch event?
	var is_touch_event = util_is_touch_event(event);
	// Ignore multi-touch or no-touch
	if (is_touch_event && (event.touches.length != 1)){
		return(true); // Allow event to propogate
	}
	// Record the piece we are manipulating for use in new event handlers we'll define
	var start_click = util_get_event_board_coordinates(event);
	var pieces = [this];
	// If shift is held, grab all pieces
	if (event.shiftKey){
		pieces = find_pieces_at_coord(start_click);
	}
	// Handle a click (no drag movement), by showing the piece menu
	var click_function = function () {
		show_board_popup_menu(pieces,{
			left: start_click.x-10,
			top: start_click.y-10
		});
	}
	var unlocked_pieces = [];
	$.each(pieces, function(i,p){
		if (!p.lock){
			unlocked_pieces.push(p);
		}
	});
	// If a piece is not locked, start a flip, rotate, move or popup depending upon
	// the button pressed
	if (unlocked_pieces.length > 0){
		if (event.which && (event.which == 2)){ // Middle mouse button, flip and start move
			pieces_flip(unlocked_pieces);
			pieces_start_move(unlocked_pieces, event, null);
		} else if (event.which && (event.which == 3)){ // Right mouse button, rotate
			pieces_start_rotate(unlocked_pieces, event);
		} else { // Left mouse button or touch, move with possible pop-up menu
			pieces_start_move(unlocked_pieces, event, click_function);
		}
		event.preventDefault(); 
		return(false);
	}
	// At this point, we know we're dealing with a locked piece. - start a multi-select event  
	board_start_multi_select(event, click_function, 0);
	event.preventDefault(); 
	return(false);
}

/*
 * piece_clone - Creates a new piece in the world that is a copy of the given piece
 * TODO: HIGH - Make sure that new features (like z index) are added to this function
 * TODO: LOW - Get setting of attributes here the same order as in creating and updating pieces
 * 
 * @param piece The piece to clone
 */
function piece_clone(piece){
	var position = util_get_position(piece);
	world_add_piece({
		"faces_array": JSON.stringify(piece.faces),
		"face_width": piece.face_width,
		"x": (position.left), 
		"y": (position.top),
		"z": piece.z,
		"lock": piece.lock,
		"shield": piece.shield,
		"orientation": piece.orientation,
		"face_showing": piece.face_showing,
		"css_class": piece.css_class,
		"event_callback": piece.event_callback,
		"custom_html": escape(piece.custom_html)
	});
}

/*
 * set_piece_face_showing - Sets the object member face_showing and updates
 * the visible face showing
 *
 * @param piece The piece to update
 * @param face_showing The face index to display
 */
function set_piece_face_showing(piece, face_showing){
	piece.face_showing = face_showing;
	$(piece).find('.piece_face').attr('src',piece.faces[piece.face_showing]);
}

/*
 * set_piece_z_index - Sets the object member z and updates the CSS
 *
 * @param piece The piece to update
 * @param z_index The new z-index
 */
function set_piece_z_index(piece, z_index){
	piece.z = z_index;
	$(piece).css("z-index",z_index);
}

/*
 * set_piece_orientation - Sets the piece orientation through CSS
 *
 * @param piece The piece to update
 * @param orientation The orientation in degrees
 */
function set_piece_orientation(piece, orientation){
	var r = "rotate(" + orientation + "deg)";
	var piece_face = $(piece).find(".piece_face");
	piece.orientation = orientation;
	$(piece_face).css("transform",r);
	$(piece_face).css("-webkit-transform",r);
	$(piece_face).css("-moz-transform",r);
	$(piece_face).css("-o-transform",r);
	$(piece_face).css("ms-transform",r);
}

/*
 * get_piece_center(piece) - returns the center coordinates (left, top) of the piece.
 * 
 * @param piece The piece object
 */
function get_piece_center(piece){
	var position = util_get_position(piece);
	return ({
		left: position.left + $(piece).width()/2,
		top: position.top + $(piece).height()/2
	});
}

/*
 * get_pieces_center(piece) - returns the center coordinates (left, top) of a group of
 * pieces.
 * 
 * @param pieces The array of pieces
 */
function get_pieces_center(pieces){
	var left_min = 0, left_max = 0, top_min = 0, top_max = 0;
	var center;
	$.each(pieces, function(i,piece){
		center = get_piece_center(piece);
		if (i == 0) {
			left_min = center.left;
			left_max = center.left;
			top_min = center.top;
			top_max = center.top;
		}
		if (left_min > center.left) {
			left_min = center.left;
		}
		if (left_max < center.left) {
			left_max = center.left;
		}
		if (top_min > center.top) {
			top_min = center.top;
		}
		if (top_max < center.top) {
			top_max = center.top;
		}
	});
	return ({
		left: Math.floor((left_min + left_max)/2),
		top: Math.floor((top_min + top_max)/2)
	});
}

/**
 * piece_see_detil - Zooms into a piece so that we can see the detail.
 * It uses an overlay, centering the current image and scaling to cover
 * the full window.
 * 
 * @param piece The piece of which we wish to see the detail
 */
function piece_see_detail(piece){
	// Add an overlay we'll use for down, move, and up events
	var overlay = util_create_ui_overlay();
	var img_url = $(piece).find('.piece_face').attr('src');
	$(overlay).css("opacity",0.9);
	$(overlay).css('background','#000 url('+encodeURI(img_url)+') center center fixed no-repeat');
	$(overlay).css('-moz-background-size','contain');
	$(overlay).css('background-size','contain');
}


/**
 * pieces_start_rotate - Rotates a set of pieces around its global center.
 * We treat mouse slightly differently
 * than touch, in that for mouse we can sense mouse movements without them pressing the button,
 * so we base the original orientation from the menu click.  For touch, we reset the start
 * orientation when they touch the screen.
 * 
 * @param pieces The set of pieces to be rotated
 * @param event The initiating event
 */
function pieces_start_rotate(pieces, event){
	// Check if mouse is moved while dragging
	var mouse_moved = 0;
	var start_coord = util_get_event_board_coordinates(event);
	var last_coord = util_clone(start_coord);
	// Add an overlay we'll use for down, move, and up events
	var overlay = util_create_ui_overlay();
	// Find the center of the group of pieces
	var pieces_center = get_pieces_center(pieces);
	// Get the starting orientation and centers of the pieces
	var start_orientations = [];
	var start_centers = [];
	$.each(pieces, function(i,piece){
		start_orientations.push(piece.orientation);
		start_centers.push(get_piece_center(piece));
	});
	// Remeber the move angle so we update only when the angle changes
	var move_angle = 0;
	var original_position_from_center = {
		x: (start_coord.x - pieces_center.left),
		y: (start_coord.y - pieces_center.top)
	};
	// Handle start drag events by resetting location for rotation calculations
	var start_drag_function = function (event){
		start_coord = util_get_event_board_coordinates(event);
		last_coord = util_clone(start_coord);
		original_position_from_center = {
			x: (start_coord.x - pieces_center.left),
			y: (start_coord.y - pieces_center.top)
		};
		event.preventDefault(); 
		return(false);
	}
	var move_pieces = function(coord, final_send){
		var new_position_from_center = {
			x: (coord.x - pieces_center.left),
			y: (coord.y - pieces_center.top)
		};
		var new_move_angle = move_angle;
		if (new_position_from_center.x != 0 || new_position_from_center.y != 0){
			new_move_angle = 
			360.0 * (Math.atan2(new_position_from_center.x,-new_position_from_center.y)
				- Math.atan2(original_position_from_center.x,-original_position_from_center.y))/(2*3.14159);
			new_move_angle = ((Math.round(new_move_angle / 5) * 5) + 360) % 360;
		}
		move_angle = new_move_angle;
		var cos_a = Math.cos(move_angle * 2 * Math.PI / 360);
		var sin_a = Math.sin(move_angle * 2 * Math.PI / 360);
		$.each(pieces, function (i,piece){
			var send_update = final_send;
			if (pieces.length == 1){ // Visibly send an update for single moves
				send_update = 1;
		    }
		    // First update the orientation, then update location
		    piece.orientation = start_orientations[i] + move_angle;
		    if (send_update){
			    // Update the world, setting the client so we can ignore the events
			    world_update_piece(piece.world_piece_index,{
				    "client": g_client_id,
				    "orientation": piece.orientation
			    });
		    }
		    // Update locally
		    set_piece_orientation(piece,piece.orientation);
		    // Now calculate and update location (once piece is turned to avoid location issues)
		    var new_center_left = ((start_centers[i].left - pieces_center.left) * cos_a -
			    (start_centers[i].top - pieces_center.top) * sin_a) + pieces_center.left;
		    var new_center_top = ((start_centers[i].left - pieces_center.left) * sin_a +
			    (start_centers[i].top - pieces_center.top) * cos_a) + pieces_center.top;
		    set_piece_location(piece,{
				left: new_center_left - $(piece).width()/2,
				top: new_center_top - $(piece).height()/2
		    },send_update);
		});
	}
	// Handle drag events by calculating and executing new piece orientation
	var drag_function = function (event) {
		var coord = util_get_event_board_coordinates(event);
		if ((coord.x != last_coord.x) || (coord.y != last_coord.y)){
			if (!mouse_moved){
				mouse_moved = 1; // We moved, so this is a drag, not a click
			}
			// Remember the last_coordinates again
			last_coord = util_clone(coord);
			move_pieces(coord,0);
		}
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	}
	// Handle the end of dragging by removing the overlay (deleting events)
	var stop_drag_function = function (event) {
		// Send update to server
		if (mouse_moved) {
			move_pieces(last_coord,1);
		}
		// Remove Highlight
		pieces_unhighlight(pieces);
		// Click on the overlay to destroy it (and remove listeners)
		$(overlay).trigger('click');
		// Call our piece callbacks
		pieces_call_event_callback(pieces, "rotate");
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	};
	// TODO: HIGH - The use of the overlay won't behave correctly on touch devices
	if (overlay.addEventListener){
		overlay.addEventListener("touchstart",start_drag_function,false);
		overlay.addEventListener("touchmove",drag_function,false);
		overlay.addEventListener("touchend",stop_drag_function,false);
		overlay.addEventListener("touchcancel",stop_drag_function,false);
	}
	$(overlay).bind("mousedown.rotatedrag",util_ignore_event); // For mouse ignore down click
	$(overlay).bind("mousemove.rotatedrag",drag_function);
	$(overlay).bind("mouseup.rotatedrag",stop_drag_function);
}

/**
 * pieces_start_move - Initiate the moving of a set of pieces.  
 * 
 * We optionally allow the use of an overlay, which is useful when we start
 * a move activity from a menu.  For mouse movements we can move the pieces
 * immediately from the menu click.  For touch, however, the finger is lifted 
 * up after a menu click, so we want for the next touch to determine our basis
 * of motion.  If the overlay is not used, we assume that the finger is already
 * down.
 * 
 * We assume the piece is not locked or we some permission to move it.
 * 
 * @param pieces An array of pieces to be moved
 * @param event The initiating event
 * @param no_move_callback A callback if the piece was not moved
 */
function pieces_start_move(pieces, event, no_move_callback){
	// Check if mouse is moved while dragging
	var mouse_moved = 0;
	// Highlight the pieces
	pieces_highlight(pieces);
	// Store where on the piece we clicked (for use with dragging)
	var start_coord = util_get_event_board_coordinates(event);
	var last_coord = util_clone(start_coord);
	var start_positions = [];
	$.each(pieces, function (i,p){
		start_positions[i] = util_get_position(p);
	});
	// Add an overlay we'll use for down, move, and up events
	var	overlay = util_create_ui_overlay();
	// Function to add a piece starting at a specific coordinate
	var add_piece_starting_at_coord = function(p,coord){
		var pos = util_get_position(p);
		pieces.push(p);
		start_positions.push({
							   left: pos.left + start_coord.x - coord.x,
							   top: pos.top + start_coord.y - coord.y
						   });
	}
	// Function to pick up new unlocked pieces at a specific coordinate and return true if found
	var grab_all_pieces_at_coord = function(coord){
		var found_piece = 0;
		// Find new pieces and scoop them into our pile
		var newpieces = find_pieces_at_coord(coord);
		$.each(newpieces,function(i,p){
			if ((!p.lock) && ($.inArray(p,pieces) < 0)){
				add_piece_starting_at_coord(p,coord);
				found_piece = 1;
			}
		});
		// If we find a new piece, move everything to the front
		if (found_piece){
			move_pieces_to_front(pieces);
		}
	}
	// Handle start drag events by resetting location for rotation calculations
	var start_drag_function = function (event){
		start_coord = util_get_event_board_coordinates(event);
		last_coord = util_clone(start_coord);
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	}
	// Avoid repeated events by recording keys that are down
	var keydown = {};
	var keydown_function = function (event){
		if(keydown[event.which] == null){
			keydown[event.which] = 1;
			if (event.which == 16) { // Shift is pressed so add pieces underneath
				grab_all_pieces_at_coord(last_coord);
				event.preventDefault(); 
			} else if (event.which == 17) { // CTRL is pressed so grab top piece
				var newpieces = find_pieces_at_coord(last_coord);
				var toppiece = null;
				// Get the top piece we don't already have
				$.each(newpieces,function(i,p){
					if ((!p.lock) && ($.inArray(p,pieces) < 0)){
						if ((toppiece == null) || (p.z > toppiece.z)){
							toppiece = p;
						}
					}
				});
				if (toppiece != null){
					add_piece_starting_at_coord(toppiece,last_coord);
					move_pieces_to_front(pieces);
				}
				event.preventDefault(); 
			} else if (event.which == 32) { // Space is pressed so drop bottom piece
				// Send a piece update
				move_pieces(last_coord,1);
				if (pieces.length > 0){
					// Remove the piece and the starting offset
					var p = pieces.pop();
					start_positions.pop();
					// Unhighlight it (in case it was)
					pieces_unhighlight([p]);
					// TODO: Execute Callback on dropped piece
				}
				event.preventDefault(); 
			}
		}
	}
	var keyup_function = function (event){
		keydown[event.which] = null;
	}
	var move_pieces = function(coord, final_send){
		$.each(pieces, function(i, piece){ 
			var send_update = final_send;
		    if (pieces.length == 1){ // Visibly send an update for single moves
				send_update = 1;
			}
			set_piece_location(piece, {
		       left: start_positions[i].left - start_coord.x + coord.x,
		       top: start_positions[i].top - start_coord.y + coord.y
	        },send_update); // Only send movement of top piece to server every half second
	   });
	}
	// Handle drag events by calculating and executing new piece orientation
	var drag_function = function (event) {
		var coord = util_get_event_board_coordinates(event);
		if ((coord.x != last_coord.x) || (coord.y != last_coord.y)){
			if (!mouse_moved){
				mouse_moved = 1; // We moved, so this is a drag, not a click
				// If we started dragging the pieces, move them to the top
				move_pieces_to_front(pieces);
			}
			// Remember the last_coordinates again
			last_coord = util_clone(coord);
			// If the shift key is down while dragging, pick up new pieces we go over
			if (event.shiftKey){
				grab_all_pieces_at_coord(coord);
			}
			move_pieces(coord,0);
		}
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	}
	// Handle the end of dragging by removing events, and calling no_move_callback if needed
	var stop_drag_function = function (event) {
		// Send update to server
		if (mouse_moved) {
			move_pieces(last_coord,1);
		}
		// Remove Highlight
		pieces_unhighlight(pieces);
		// Click on the overlay to destroy it (and remove listeners)
		$(overlay).trigger('click');
		$(document).unbind("keydown",keydown_function);
		$(document).unbind("keyup",keyup_function);
		if ((!mouse_moved) && (no_move_callback)){
			// Call our callback if we clicked (didn't move)
			no_move_callback();
		} else {
			// Call our piece callbacks
			pieces_call_event_callback(pieces,"move");
		}
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	};
	if (overlay.addEventListener){
		overlay.addEventListener("touchstart",start_drag_function,false);
		overlay.addEventListener("touchmove",drag_function,false);
		overlay.addEventListener("touchend",stop_drag_function,false);
		overlay.addEventListener("touchcancel",stop_drag_function,false);
	}
	$(overlay).bind("mousedown.movedrag",util_ignore_event); // For mouse ignore down click
	$(overlay).bind("mousemove.movedrag",drag_function);
	$(overlay).bind("mouseup.movedrag",stop_drag_function);
	$(document).bind("keydown",keydown_function);
	$(document).bind("keyup",keyup_function);
}

/**
 * board_start_area_highlight - Initiate highlight of a region of the desktop
 * Like the other drag events, for mouse we ignore additional mouse-down, while for
 * touch, we reset the location of the highlight area on a touch start.
 * 
 * @param event The initiating event
 * @param area_select_callback Callback (rect,event) when area is highlighted 
 * @param use_overlay Create an overlay to capture new mouse event
 */
function board_start_area_highlight(event, area_select_callback, use_overlay){
	var start_click = util_get_event_board_coordinates(event);
	var highlight_position = {
		left: start_click.x, 
		top: start_click.y
	};
	var highlight_dimensions = {
		width: 0, 
		height: 0
	};
	var overlay = 0;
	if (use_overlay){
		// Add an overlay we'll use for down, move, and up events
		overlay = util_create_ui_overlay();
	}
	// Add a highlight div
	var jq_highlight = $('<div class="abg_highlight"></div>');
	$('#board').append(jq_highlight);
	jq_highlight.css('background-color','#0000FF');
	jq_highlight.css('opacity',0.5);
	jq_highlight.css('position','absolute');
	jq_highlight.css('z-index','999'); // Below overlay but above pieces
	jq_highlight.css('border','1px dashed #A0A0FF');
	jq_highlight.css('left',highlight_position.left).css('top',highlight_position.top);
	jq_highlight.width(highlight_dimensions.width);
	jq_highlight.height(highlight_dimensions.height);	
	// Handle a starting touch by restarting the highlight area there
	var start_drag_function = function (event){
		start_click = util_get_event_board_coordinates(event);
		highlight_position = {
			left: start_click.x, 
			top: start_click.y
		};
		highlight_dimensions = {
			width: 0, 
			height: 0
		};
		jq_highlight.css('left',highlight_position.left).css('top',highlight_position.top);
		jq_highlight.width(highlight_dimensions.width);
		jq_highlight.height(highlight_dimensions.height);	
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	}
	// Handle a drag by highlighting the area
	var drag_function = function (event) {
		var click = util_get_event_board_coordinates(event);
		highlight_position = {
			left: Math.min(click.x, start_click.x),
			top: Math.min(click.y, start_click.y)
		};
		highlight_dimensions = {
			width: Math.abs(click.x - start_click.x),
			height: Math.abs(click.y - start_click.y)
		};
		jq_highlight.css('left',highlight_position.left).css('top',highlight_position.top);
		jq_highlight.width(highlight_dimensions.width);
		jq_highlight.height(highlight_dimensions.height);	
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	}
	var stop_drag_function = function (event) {
		jq_highlight.remove();
		if (overlay){
			// Click on the overlay to destroy it (and remove listeners)
			$(overlay).trigger('click');
		}
		// Remove the document event listeners
		if ($("#board").get(0).removeEventListener){
			$("#board").get(0).removeEventListener("touchmove",drag_function,false);
			$("#board").get(0).removeEventListener("touchend",stop_drag_function,false);
			$("#board").get(0).removeEventListener("touchcancel",stop_drag_function,false);
		}
		$("#board").unbind("mousemove",drag_function);
		$("#board").unbind("mouseup",stop_drag_function);
		// Call our callback
		if (area_select_callback){
			area_select_callback({
				x: highlight_position.left,
				y: highlight_position.top,
				width: highlight_dimensions.width,
				height: highlight_dimensions.height
			},event);
		}
		// We do not want regular event processing
		event.preventDefault(); 
		return(false);
	};
	if ($("#board").get(0).addEventListener){
		if (overlay){
			overlay.addEventListener("touchstart",start_drag_function,false);
		}
		$("#board").get(0).addEventListener("touchmove",drag_function,false);
		$("#board").get(0).addEventListener("touchend",stop_drag_function,false);
		$("#board").get(0).addEventListener("touchcancel",stop_drag_function,false);
	}
	$("#board").bind("mousemove",drag_function);
	$("#board").bind("mouseup",stop_drag_function);
}

/*
 * piece_in_rect - returns true if the given piece's center is in the rect (x,y,width,height)
 * 
 * @param piece
 * @param rect
 */
function piece_in_rect(piece, rect){
	var center = get_piece_center(piece);
	return ((center.left >= rect.x) && (center.left <= (rect.x + rect.width))
		&& (center.top >= rect.y) && ((center.top <= (rect.y + rect.height))));
}

/*
 * point_in_piece - returns true if the point is in the piece
 * @param piece
 * @param point (x,y)
 */
function point_in_piece(piece, point){
	var position = util_get_position(piece);
	return ((position.left <= point.x) && 
			((position.left + $(piece).width()) >= point.x) &&
			(position.top <= point.y) && 
			((position.top + $(piece).height()) >= point.y));
}

/*
 * find_pieces_at_coord - returns all pieces that hit a specific point
 * @param point (x,y)
 */
function find_pieces_at_coord(coord){
	var pieces = [];
	$.each(g_pieces,function(i,p){
			   if (point_in_piece(p,coord)){
				   pieces.push(p);
			   }
		   });
	return pieces;
}

/*
 * show_board_popup_menu - Generates the pop-up menu for the given pieces.
 * 
 * @param pieces The selected pieces (potentially empty)
 * @param position (left, top) position for the pop-up
 */
function show_board_popup_menu(pieces, position){
	var menu_items = [];
	var locked_pieces = [];
	var unlocked_pieces = [];
	var piece = null;
	var max_sides = 1;
	if (pieces.length == 1){
		piece = pieces[0];
	}
	// Figure out which pieces are locked, and which are unlocked
	$.each(pieces, function (index,piece){
		if (piece.lock){
			locked_pieces.push(piece);
		} else {
			unlocked_pieces.push(piece);
		}
	});
	// If we have unlocked pieces, highlight them and calculate the max sides
	if (unlocked_pieces.length > 0){
		// Highlight the unlocked pieces
		pieces_highlight(unlocked_pieces);
		// Calculate the max sides for the unlocked pieces
		max_sides = 1;
		$.each(unlocked_pieces, function (i,piece){
			if (piece.faces.length > max_sides) {
				max_sides = piece.faces.length;
			}
		});
	}
	// Now add the menu items
	// ----- Piece manipulation for unlocked pieces
	if (unlocked_pieces.length > 0){
		if (max_sides > 2){
			menu_items.push({
				label: "Roll", 
				callback: function(event){
					pieces_roll(unlocked_pieces,5);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		if (max_sides > 1){
			menu_items.push({
				label: "Flip", 
				callback: function(event){
					pieces_flip(unlocked_pieces);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		if (max_sides == 2){
			menu_items.push({
				label: "Random Flip", 
				callback: function(event){
					pieces_roll(unlocked_pieces,5);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		if (max_sides > 1){
			menu_items.push({
				label: "Flip to first side", 
				callback: function(event){
					pieces_flip_to_first_side(unlocked_pieces);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		if (unlocked_pieces.length > 1){
			menu_items.push({
				label: "Shuffle", 
				callback: function(event){
					pieces_shuffle(unlocked_pieces, event);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		if (unlocked_pieces.length > 1){
			menu_items.push({
				label: "Stack", 
				callback: function(event){
					pieces_stack(unlocked_pieces);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		menu_items.push({
			label: "Rotate", 
			callback: function(event){
				pieces_start_rotate(unlocked_pieces, event);
			}, 
			args: null
		});
		menu_items.push({
			label: "Move", 
			callback: function(event){
				pieces_start_move(unlocked_pieces, event);
			}, 
			args: null
		});
		// Allow multiple pieces or non shields to be sent to the back
		if (!piece || !piece.shield){ 
			menu_items.push({
				label: "Send to back", 
				callback: function(event){
					move_pieces_to_back(unlocked_pieces);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		// Menu items for a single-selected unlocked piece
		if (piece){
			menu_items.push({
				label: "View Detail", 
				callback: function(event){
					piece_see_detail(piece, event);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
			menu_items.push({
				label: "Edit...", 
				callback: function(){
					open_add_edit_piece_dialog(piece);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
		menu_items.push({
			label: "Lock", 
			callback: function(){
				$.each(unlocked_pieces,function(i,piece){
					world_update_piece_accumulate(piece.world_piece_index,{
						"lock": 1
					});
					piece.lock = 1;
				});
				world_update_piece_accumulate_flush();
				pieces_unhighlight(unlocked_pieces);
			}, 
			args: null
		});
		menu_items.push({
			label: "Clone", 
			callback: function(event){
				// Copy all the pieces and start a move on the original copies
				$.each(unlocked_pieces,function(i,piece){
					piece_clone(piece);
				});
				pieces_start_move(unlocked_pieces, event);
			}, 
			args: null
		});
		menu_items.push({
			label: "Delete", 
			callback: function(){
				// Set the piece to null to delete it
				$.each(unlocked_pieces,function(i,piece){ 
					world_update_piece_accumulate(piece.world_piece_index, null);
				});
				world_update_piece_accumulate_flush();
			}, 
			args: null
		});
	}
	// ----- Piece manipulation for shields
	// If we selected one piece and it is a shield, allow the user to manipulate it
	if (piece && piece.shield){
		if (piece.z == 0){
			menu_items.push({
				label: "Let another player use this shield", 
				callback: function(){
					set_piece_z_index(piece, 980);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		} else {
			menu_items.push({
				label: "Use this shield for your hand", 
				callback: function(){
					set_piece_z_index(piece, 0);
					pieces_unhighlight(unlocked_pieces);
				}, 
				args: null
			});
		}
	}
	// ----- Piece manipulation for locked pieces
	if (locked_pieces.length > 0){
		menu_items.push({
			label: "Unlock", 
			callback: function(){
				$.each(locked_pieces,function(i,piece){
					world_update_piece_accumulate(piece.world_piece_index,{
						"lock": 0
					});
					piece.lock = 0;
				});
				world_update_piece_accumulate_flush();
				pieces_unhighlight(unlocked_pieces);
			}, 
			args: null
		});
	}
	// ----- Board menu items
	if (unlocked_pieces.length == 0) {
		menu_items.push({
			label: "Add Piece...", 
			callback: function(){
				open_add_edit_piece_dialog();
			}, 
			args: null
		});
		menu_items.push({
			label: "Open Board...", 
			callback: function(){
				$( '#upload_board_dialog' ).dialog('open');
			}, 
			args: null
		});
		menu_items.push({
			label: "Save Board...", 
			callback: function(){
				world_save_world();
			}, 
			args: null
		});
		menu_items.push({
			label: "Clear Board", 
			callback: function(){
				if (confirm("Are you sure you wish to clear the board?")){
					world_update(0); // Updating the world to 0 clears it
				}
			}, 
			args: null
		});
		menu_items.push({
			label: "Redirect to URL...", 
			callback: function(){
				s = prompt('Enter a URL to which all players will be redirected:','');
				if (s){
					var piece_data = {
						"faces_array": JSON.stringify(["about:blank"]),
						"face_width": 1,
						"custom_html": '%3Cscript%3E' + escape('if(confirm(\'The board is redirecting to the URL '+s+'. Is that OK?\')) { window.location = "'+encodeURI(s)+'";}') + '%3C/script%3E'
					};
					world_add_piece(piece_data);
				}
			}, 
			args: null
		});
		menu_items.push({
			label: "Help", 
			callback: function(){
				window.open("http://www.anywhereboardgames.com/help/");
			}, 
			args: null
		});
	}
	create_popup_menu(menu_items, $('#board'), util_board_to_page_coord(position), function(event){
		pieces_unhighlight(unlocked_pieces);
	//		pieces_start_move(unlocked_pieces, event, 0);
	});
}

/*
 * board_start_multi_select - Allows the user to highlight a region and then
 * depicts a pop-up menu for multi-selected items.  If the highlighted region
 * is zero size, the user did a click without a drag, so we allow the caller
 * to specify a click callback to handle that event.
 * 
 * @param event The event that initiated the multi-select
 * @param click_callback A callback in case the user did not drag
 * @param use_overlay Create an overlay to capture new mouse event
 */
function board_start_multi_select(event, click_callback, use_overlay){
	board_start_area_highlight(event, function(rect, e){
		var highlighted_pieces = [];
		$.each(g_pieces, function (index,value){
			if (piece_in_rect(value,rect)) {
				highlighted_pieces.push(value);
			}
		});
		if (highlighted_pieces.length > 0){
			var coord = util_get_event_board_coordinates(e);
			show_board_popup_menu(highlighted_pieces, {
				left: coord.x-10,
				top: coord.y-10
			});
		} else {
			// If rect is empty, do a click event
			if (click_callback){
				click_callback(e);
			}
		}
	}, use_overlay);
}

/*
 * on_board_click - handler for board click events. If we are the destination of
 * the click, then pop-up the menu.
 *
 * @param event Click event
 */
function on_board_click(event){
	var click = util_get_event_board_coordinates(event);
	/*
	if (event.target.nodeName == "HTML"){
		show_board_popup_menu([],{
			left: click.x-10,
			top: click.y-10
		});
		event.preventDefault(); 
		return false;
	}
	*/
	return true;
}

/*
 * on_board_mouse_down - event handler for mouse on the board
 *  - This will kick off a multi-select which if empty will result in on_board_click
 *    to be called
 *
 * @param event
 */
function on_board_mouse_down(event){
	if ($(event.target).is("#board")){
		// Make sure click isn't on a scroll bar
		if (util_is_in_scrollbar(event)) return (true);
		// For touch devices, this will always be empty and call on_board_click
		board_start_multi_select(event, 
			function(event){
				var click = util_get_event_board_coordinates(event);
				show_board_popup_menu([],{
					left: click.x-10,
					top: click.y-10
				});
				event.preventDefault(); 
				return false;
			}, 0);
		event.preventDefault(); 
		return (false);
	}
	return (true);
}

// Register multi-select on touch down (empty multi-select brings up pop-up menu)
$(document).ready(function(){
	$("#board").bind("mousedown", on_board_mouse_down);
	// Add mouse touch event (for mobile devices)
	if ($("#board").get(0).addEventListener){
		$("#board").get(0).addEventListener("touchstart",on_board_mouse_down);
	}
});

/*
 * open_add_edit_piece_dialog - Creates a jquery dialog to get the data necessary
 * to add or edit a piece on the board.  This includes the ability to add a dynamic
 * number of faces (image URLs).
 *
 * @param piece If specified, the existing piece will be modified
 */
function open_add_edit_piece_dialog(piece){
	var dialog = $('<div title="Add a New Piece"><form><fieldset id="faces_fields">' +
		'</fieldset><fieldset id="other_fields"></fieldset></form></div>');
	if (piece){
		$.each(piece.faces,function(i,face){
			var new_url = $('<br/><label>Face URL:</label> ' +
				'<input style="width: 75%;" type="text" name="face_url[]" ' +
				'title="The URL of an image to use as the piece\'s face" ' +
				'class="text ui-widget-content ui-corner-all" value="' + face + '"/>');
			dialog.find("#faces_fields").append(new_url);
		});
	} else {
		var new_url = $('<br/><label>Face URL:</label> ' +
			'<input style="width: 75%;" type="text" name="face_url[]" ' +
			'title="The URL of an image to use as the piece\'s face" ' +
			'class="text ui-widget-content ui-corner-all" />');
		dialog.find("#faces_fields").append(new_url);
	}
	// Add width
	dialog.find("#other_fields").append(
		$('<br/><label>Width:</label> ' +
			'<input style="width: 75%;" type="text" name="face_width" ' +
			'title="The piece will be scaled to this width in pixels." ' +
			((piece && piece.face_width)?('value="'+piece.face_width+'"'):"") +
			'class="text ui-widget-content ui-corner-all" />'));
	// Add shield checkbox
	dialog.find("#other_fields").append(
		$('<br/><label> </label><input type="checkbox" name="shield" value="1" ' + 
			'title="If checked, the piece will stay in front of other pieces, hiding them except for the player who claims the shield." ' +
			((piece && piece.shield)?('checked="true"'):"") +
			"/><span> Use piece as a player's hand shield</span>"));
	// Add CSS Class
	dialog.find("#other_fields").append(
		$('<br/><label>CSS Class:</label> ' +
			'<input style="width: 75%;" type="text" name="css_class" ' +
			'title="The piece is assigned the given CSS classes, which is useful for styling or JavaScript coding." ' +
			((piece && piece.css_class)?('value="'+piece.css_class+'"'):"") +
			'class="text ui-widget-content ui-corner-all" />'));
	// Add Event Callback
	dialog.find("#other_fields").append(
		$('<br/><label>Callback:</label> ' +
			'<input style="width: 75%;" type="text" name="event_callback" ' +
			'title="When the piece is moved or rotated this event callback is called: callback(piece_object, event_type)" ' +
			((piece && piece.event_callback)?('value="'+piece.event_callback+'"'):"") +
			'class="text ui-widget-content ui-corner-all" />'));
	// Add Custom HTML textarea
	dialog.find("#other_fields").append(
		$('<br/><span><label style="vertical-align: top; margin-top: 10px;">Custom HTML:</label> ' +
			'<textarea rows="3" style="width: 75%;" name="custom_html" ' +
			'title="This custom HTML is placed in the piece (and can be used to add HTML elements and JavaScript)" ' +
			'>' + 
			((piece)?(piece.custom_html):"") +
			"</textarea></span>"));
	// Add to the board
	$("#board").append(dialog);
	// Open the dialog
	dialog.dialog({
		dialogClass: 'bga_dialog bga_small_text_dialog',
		autoOpen: false,
		height: 300,
		width: 350,
		modal: true,
		buttons: {
			"Add a face": function() {
				var new_url = $('<br/><label>Face URL:</label> ' +
					'<input style="width: 75%;" type="text" name="face_url[]" ' +
					'title="The URL of an image to use as the piece\'s face" ' +
					'class="text ui-widget-content ui-corner-all" />');
				dialog.find("#faces_fields").append(new_url);
			},
			"OK": function() {
				// Get dialog values
				var face_width = dialog.find('input[name="face_width"]').val();
				var shield = dialog.find('input[name="shield"]').get(0).checked;
				var css_class = dialog.find('input[name="css_class"]').val();
				var event_callback = dialog.find('input[name="event_callback"]').val();
				var custom_html = dialog.find('textarea[name="custom_html"]').val();
				// Accumulate the face URLs
				var faces = [];
				dialog.find('input[name="face_url[]"]').each(function(idx,item){
					if ($(item).val()){
						faces.push($(item).val());
					}
				});
				if (faces.length == 0){
					alert("Please enter an image URL");
				} else {
					var piece_data = {
						"faces_array": JSON.stringify(faces),
						"face_width": face_width,
						"css_class": css_class,
						"event_callback": event_callback,
						"custom_html": escape(custom_html)
					};
					if (piece){
						world_update_piece(piece.world_piece_index, piece_data);
						// Update shield state
						// TODO: LOW - Why do we do this here and not in the update function?
						if (shield != piece.shield){
							if (shield){
								// Turn into a shield and bring to front
								world_update_piece(piece.world_piece_index,{
									"shield": 1,
									"z": 980
								});
								set_piece_z_index(piece, 980);
								piece.shield = 1;
							} else {
								// Turn off the shield and push to back
								world_update_piece(piece.world_piece_index,{
									"shield": 0,
									"z": 0
								});
								set_piece_z_index(piece, 0);
								piece.shield = 0;
							}
						}
					} else {
						piece_data.x = 50;
						piece_data.y = 50;
						piece_data.z = g_pieces.length;
						// If the new piece is a shield, move it up front
						piece_data.shield = shield ? shield : 0;
						if (shield){
							piece_data.z = 980;
						}
						world_add_piece(piece_data);
					}
					$(this).dialog( "close" );
					$(this).remove();
				}
			},
			Cancel: function() {
				$(this).dialog( "close" );
				$(this).remove();
			}
		}
	});
	// Bind enter to OK to avoid submitting the form to the script
	/*
	dialog.bind("keydown", function(e){
		if (e.keyCode == 13){
			e.preventDefault();
			$(dialog).parent().find(':button:contains("OK")').click();
			return false;
		}
		return true;
	});
	*/
	dialog.dialog('open');
}

// TODO: LOW - Keyboard interactions
/*
	  function board_keypress(event){
		  if ((event.which == 43) || (event.which == 45) || (event.which == 48)){
		  event.preventDefault();
		  if (!this.zoom_level){
			  this.zoom_level = 1;
		  }
		  if (event.which == 45){
			  this.zoom_level = this.zoom_level * 0.9;
		  }
		  if (event.which == 43){
			  this.zoom_level = this.zoom_level / 0.9;
		  }
		  if (event.which == 48){
			  this.zoom_level = 1;
		  }
		  var r = "scale(" + this.zoom_level + ")";
		  $("body").css("transform",r);
		  $("body").css("transform-origin","0% 0%");
		  $("body").css("-webkit-transform",r);
		  $("body").css("-webkit-transform-origin","0% 0%");
		  $("body").css("-moz-transform",r);
		  $("body").css("-moz-transform-origin","0% 0%");
		  $("body").css("-ms-transform",r);
		  $("body").css("-ms-transform-origin","0% 0%");
		  }
	  }
 */
/**
*
*  This is updated from the Ajax IFrame Method in http://www.webtoolkit.info/
*
**/

// TODO: LOW - Delete the div after it is submitted

var IFrameSubmit = {

	frame : function(c) {
		var n = 'f' + Math.floor(Math.random() * 99999);
		var d = document.createElement('DIV');
		d.innerHTML = '<iframe style="display:none" src="about:blank" id="'+n+'" name="'+n+'" onload="IFrameSubmit.loaded(\''+n+'\')"></iframe>';
		document.body.appendChild(d);

		var i = document.getElementById(n);
		if (c && typeof(c.onComplete) == 'function') {
			i.onComplete = c.onComplete;
		}

		return n;
	},

	form : function(f, name) {
		f.setAttribute('target', name);
	},

	submit : function(f, c) {
		IFrameSubmit.form(f, IFrameSubmit.frame(c));
		if (c && typeof(c.onStart) == 'function') {
			return c.onStart();
		} else {
			return true;
		}
	},

	loaded : function(id) {
		var d;
		var i = document.getElementById(id);
		if (i.contentDocument) {
			d = i.contentDocument;
		} else if (i.contentWindow) {
			d = i.contentWindow.document;
		} else {
			d = window.frames[id].document;
		}
		if (d.location.href == "about:blank") {
			return;
		}

		if (typeof(i.onComplete) == 'function') {
			i.onComplete(d.body.innerHTML);
		}
	}

}
        </script>
		<script type="text/javascript">
	
			// TODO: LOW - Add error checking from http://jqueryui.com/demos/dialog/modal-form.html
			$(document).ready(function() {
				$( "#upload_board_dialog" ).dialog({
					dialogClass: 'bga_dialog bga_small_text_dialog',
					autoOpen: false,
					height: 300,
					width: 350,
					modal: true,
					open: function(event, ui) {
						$("#upload_board_form").get(0).reset();
					},
					buttons: {
						"OK": function() {
							var file = $("#upload_board_file").val();
							var url = $("#upload_board_url").val();
							var url_select = $("#upload_board_select").val();
							var clear_world = $("#upload_board_clear_world").attr('checked');
							// If a URL is selected copy it over
							if (url_select){
								$("#upload_board_url").val(url_select);
			                    url = url_select;
							}
							if (!file && !url && !url_select){
								alert("Please enter or select an ABG file");
							} else {
			                    if (url) {
			                        world_load_from_url(url, clear_world);
			                    } else {
									world_load_from_file($("#upload_board_file").get(0).files[0], clear_world);
			                    }
								// Reset the last timestamp of the world
								world_listener_start.world_last_ts = 0;
								$( this ).dialog( "close" );
							}
						},
						Cancel: function() {
							$( this ).dialog( "close" );
						}
					}
				});
				// Bind enter to OK to avoid submitting the form to the script
				$( "#upload_board_dialog" ).bind("keydown", function(e){
					if (e.keyCode == 13){
						e.preventDefault();
						$( "#upload_board_dialog" ).parent().find(':button:contains("OK")').click();
						return false;
					}
					return true;
				})
				// Ignore Context Menu
				$(document).bind("contextmenu",util_ignore_event);
			});
	

		</script>
		<style>
			.bga_small_text_dialog { font-size: 67.5%; }
			.bga_dialog fieldset { padding:0; border:0; }
			#board img, #board div, #board span { -webkit-tap-highlight-color:rgba(0,0,0,0);
		</style>
	</head>
 	<body style="background-color: #000000;">
      <div id="board" style="position: relative; width: 100%; height: 100%; overflow: auto; background-color: #001000;">
		<!-- scrolling="no" -->
		<div id="info"></div>
		<div id="upload_board_dialog" title="Open a Board">
			<form enctype="multipart/form-data" id="upload_board_form" method="POST">
				<fieldset>
					<span><B>Please select a pre-created board or set of pieces:</B></span>
					<BR/>
					<label>Select one:</label>
					<select style="width: 75%;" name="url_select" id="upload_board_select" class="ui-widget-content ui-corner-all">
						<option value="">-</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/checkers.abg.txt">Games: Checkers</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/chess.abg.txt">Games: Chess</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/go.abg.txt">Games: Go</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/reversi.abg.txt">Games: Reversi</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/words.abg.txt">Games: Words</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/deck.abg.txt">Pieces: Blue deck of cards</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/dice.abg.txt">Pieces: 6-sided Dice</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/quarter.abg.txt">Pieces: A flipping coin</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/intro.abg.txt">Introduction</option>
						<option value="https://dl.dropboxusercontent.com/u/10065648/abg/agricola_express.abg.txt">Games: Agricola Express</option>
					</select>
					<P></P>
					<span><B>Or upload your own ABG file or URL:</B></span>
					<BR/>
					<input type="hidden" name="action" value="upload" />
					<label for="upload_board_file">Board File:</label>
					<input type="file" name="file" id="upload_board_file" class="text ui-widget-content ui-corner-all" />
					<BR/>
					<label for="upload_board_url">URL:</label>
					<input type="text" style="width: 75%;" name="url" id="upload_board_url" class="text ui-widget-content ui-corner-all" />
					<P></P>
					<span>
						<input type="checkbox" name="clear_world" id="upload_board_clear_world" checked="checked" value="1">
						Clear the current board
					</span>
				</fieldset>
			</form>
		</div>
      </div>
	</body>
</html>
    ]]>
  </Content>
</Module>
